<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" charset="UTF-8"/>
  <title>The Researcher‚Äôs Quest RPG</title>
  <style>
    :root {
      --bg: #0f172a;
      --card-bg: #111827;
      --accent: #38bdf8;
      --accent-soft: rgba(56,189,248,0.1);
      --accent-strong: #0ea5e9;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --border-subtle: #1f2937;
      --danger: #f97373;
      --radius-lg: 18px;
      --radius-md: 12px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 50%, #020617 100%);
      color: var(--text-main);
      display: flex;
      justify-content: center;
      min-height: 100vh;
      padding: 24px;
    }

    #app {
      width: 100%;
      max-width: 1100px;
      background: linear-gradient(145deg, #020617 0, #020617 40%, #030712 100%);
      border-radius: 24px;
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow:
        0 18px 45px rgba(15, 23, 42, 0.9),
        0 0 0 1px rgba(15, 23, 42, 0.7);
      padding: 24px 28px 20px;
      position: relative;
      overflow: hidden;
    }

    h1, h2, h3 {
      margin: 0;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .title-main {
      font-size: 1.6rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .title-pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.5);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .subtitle {
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.4);
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.15), transparent);
      font-size: 0.75rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--accent);
    }

    .badge span {
      display: inline-block;
    }

    .steps {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 16px;
    }

    .step-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.78rem;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      color: var(--text-muted);
      cursor: pointer;
      background: rgba(15, 23, 42, 0.8);
      transition: all 0.18s ease;
    }

    .step-pill span.num {
      width: 18px;
      height: 18px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      border: 1px solid var(--border-subtle);
    }

    .step-pill.active {
      border-color: var(--accent-strong);
      color: var(--accent-strong);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.16), rgba(15, 23, 42, 0.96));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.2);
    }

    .step-pill.completed:not(.active) {
      border-color: rgba(34, 197, 94, 0.7);
      color: rgba(34, 197, 94, 0.9);
    }

    .step-pill.completed:not(.active) span.num {
      border-color: rgba(34, 197, 94, 0.7);
    }

    .step-pill:hover {
      border-color: var(--accent);
    }

    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(8px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

.step-container {
      margin-top: 10px;
      padding: 18px 16px 14px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.09), rgba(15, 23, 42, 0.98));
      animation: fadeInUp 0.35s ease;
    }

    .step-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
      margin-bottom: 10px;
    }

    .step-header h2 {
      font-size: 1.15rem;
    }

    .step-tagline {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .grid {
      display: grid;
      gap: 12px;
    }

    .two-col {
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }

    .card {
      background: rgba(15, 23, 42, 0.9);
      border-radius: var(--radius-md);
      border: 1px solid var(--border-subtle);
      padding: 10px 12px;
    }

    .card h3 {
      font-size: 0.95rem;
      margin-bottom: 6px;
    }

    .card small {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    label {
      font-size: 0.8rem;
      display: block;
      margin-bottom: 2px;
      color: var(--text-muted);
    }

    input[type="text"],
    textarea,
    select {
      width: 100%;
      background: rgba(15, 23, 42, 0.9);
      border-radius: 10px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      padding: 7px 9px;
      font-size: 0.85rem;
      color: var(--text-main);
      outline: none;
      transition: border 0.18s ease, box-shadow 0.18s ease;
    }

    textarea {
      resize: vertical;
      min-height: 80px;
      max-height: 180px;
    }

    input[type="text"]:focus,
    textarea:focus,
    select:focus {
      border-color: var(--accent-strong);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
    }

    .roles-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
    }

    .role-card {
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      padding: 8px 9px;
      font-size: 0.8rem;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.9);
      display: flex;
      flex-direction: column;
      gap: 4px;
      transition: all 0.2s ease;
    }

    .role-card input {
      display: none;
    }

    .role-card span.name {
      font-weight: 600;
      color: var(--text-main);
    }

    .role-card span.desc {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .role-card.selected {
      border-color: var(--accent-strong);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.24), rgba(15, 23, 42, 0.95));
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.3);
    }

    .keyword-row {
      display: flex;
      gap: 8px;
      margin-bottom: 6px;
    }

    .keyword-row input {
      flex: 1;
    }

    .keyword-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 6px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.95);
      border: 1px solid rgba(31, 41, 55, 0.9);
      font-size: 0.75rem;
    }

    .keyword-item span.keyword {
      padding: 0 4px;
      font-weight: 500;
    }

    .keyword-item select {
      width: 150px;
      font-size: 0.75rem;
      padding: 2px 4px;
    }

    .keyword-remove {
      cursor: pointer;
      padding: 0 5px;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .group-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .chip {
      font-size: 0.75rem;
      border-radius: 999px;
      padding: 2px 7px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-muted);
    }

    .options-list {
      max-height: 190px;
      overflow-y: auto;
      padding-right: 4px;
    }

    .option-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 3px 0;
      font-size: 0.8rem;
    }

    .option-item input {
      margin-top: 3px;
    }
    
    .option-item.limit-reached {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .hint {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 3px;
    }

    .summary-block {
      font-size: 0.85rem;
      line-height: 1.4;
    }

    .summary-block strong {
      color: var(--accent);
    }

    .summary-line {
      margin-bottom: 5px;
    }
    
    .narrative-block {
        padding: 20px 20px;
        border-radius: var(--radius-lg);
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(56, 189, 248, 0.3);
        margin-bottom: 12px;
    }

    .narrative-block h3 {
        color: var(--accent);
        font-size: 1.2rem;
        margin-bottom: 8px;
    }
    
    .narrative-block p {
        font-size: 0.9rem;
        line-height: 1.5;
        color: var(--text-main);
        margin-top: 0;
        margin-bottom: 12px;
    }


    .xp-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 6px;
      margin-top: 8px;
    }

    .xp-field {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 0.8rem;
    }

    .xp-field input {
      text-align: center;
      max-width: 60px;
      margin-top: 2px;
    }

    .xp-total {
      font-size: 0.9rem;
      margin-top: 6px;
      padding-top: 4px;
      border-top: 1px dashed rgba(148, 163, 184, 0.4);
    }

    .rank-label {
      font-size: 0.8rem;
      color: var(--accent);
      margin-top: 4px;
    }

    .buttons {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
      gap: 8px;
    }

    .btn {
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      padding: 7px 14px;
      font-size: 0.85rem;
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.18s ease;
    }

    .btn.primary {
      border-color: var(--accent-strong);
      background: linear-gradient(135deg, var(--accent-strong), #0369a1);
      color: #0b1220;
      font-weight: 600;
      box-shadow: 0 10px 25px rgba(8, 47, 73, 0.6);
    }

    .btn.primary:hover {
      filter: brightness(1.05);
      transform: translateY(-1px);
      box-shadow: 0 12px 30px rgba(8, 47, 73, 0.7);
    }

    .btn.secondary:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
      transform: none;
    }

    .footer-note {
      margin-top: 10px;
      font-size: 0.7rem;
      color: var(--text-muted);
      text-align: right;
    }

    .copyright {
        margin-top: 5px;
        font-size: 0.65rem;
        color: var(--text-muted);
        text-align: right;
        opacity: 0.6;
    }

    @media (max-width: 640px) {
      #app {
        padding: 18px 14px 16px;
      }
      .step-container {
        padding: 12px 10px;
      }
    }
  
    .compact-theory {
      margin-top: 10px;
      font-size: 0.8rem;
    }

    .compact-theory summary {
      cursor: pointer;
      color: var(--accent);
    }

    .compact-theory .theory-table {
      margin-top: 6px;
      max-height: 210px;
      overflow: auto;
    }

    .compact-theory table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .compact-theory th,
    .compact-theory td {
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 4px 6px;
      vertical-align: top;
    }

    .compact-theory th {
      background: rgba(15, 23, 42, 0.9);
      color: var(--accent);
    }

    .scenario-tools {
      margin: 6px 0 8px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .scenario-tools select {
      width: 100%;
      font-size: 0.8rem;
    }
/* -------------------------------------- */
/* RESPONSIVE LAYOUT ENHANCEMENTS */
/* -------------------------------------- */

/* Small screens (Max width 640px) */
@media (max-width: 640px) {
  body {
      padding: 12px; /* Reduce global padding */
  }
  #app {
    padding: 16px 12px 14px; /* Reduce internal padding */
  }
  .step-container {
    padding: 12px 10px;
  }
  /* Force two-column layout to stack vertically */
  .two-col {
    grid-template-columns: 1fr;
  }
  .roles-grid {
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  }
  .xp-grid {
    grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); /* More compression for XP fields */
  }
  .keyword-item {
    flex-wrap: wrap; /* Allow keyword row elements to wrap */
  }
  .keyword-item select {
    width: 100%; /* Full width for select boxes when wrapped */
    margin-top: 4px;
  }
}

/* Extra Small screens (Max width 480px) - Header stacking and font reduction */
@media (max-width: 480px) {
    .header {
        flex-direction: column; /* Stack header elements */
        align-items: flex-start;
        gap: 8px;
    }
    .title-main {
        font-size: 1.3rem; /* Reduce main title size */
    }
    .title-pill {
        display: none; /* Hide the pill title to save space */
    }
    .subtitle {
        font-size: 0.75rem;
    }
    .badge {
        align-self: flex-end; /* Push the badge to the right */
    }
    /* Make roles grid more compact */
    .roles-grid {
        grid-template-columns: 1fr; /* Single column stack for roles if too narrow */
    }
    .step-pill {
        font-size: 0.7rem;
        padding: 5px 8px;
    }
    .step-pill span.num {
        width: 16px;
        height: 16px;
        font-size: 0.6rem;
    }
}
</style>
</head>
<body>
  <div id="app">
    <div class="header">
      <div class="title-block">
        <div class="title-main">
          üéì The Researcher‚Äôs Quest
          <span class="title-pill">RPG Classroom Tool</span>
        </div>
        <div class="subtitle">
          Build a research pathway: <strong>Problem ‚Üí Theory ‚Üí Methodology ‚Üí Methods</strong>
        </div>
      </div>
      <div class="badge">
        <span>GM Mode: Local Browser</span>
      </div>
    </div>

    <div class="steps" id="stepsBar">
      </div>

    <div id="stepContent">
      </div>

    <div class="footer-note">
      Tip: This file runs entirely locally. Save your work by taking screenshots or copying the summary text.
    </div>
    <div class="copyright">
      &copy; 2025 Nayeem Al-Hasib, Assistant Professor, Department of English, Varendra University
    </div>
  </div>

  <script>

    // --- Simple Sound Effects (Web Audio API) ---
    let audioCtx = null;
    function getAudioContext() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        audioCtx = new AC();
      }
      return audioCtx;
    }

    function playSfx(type = "click") {
      const ctx = getAudioContext();
      if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);

      let freq = 380;
      if (type === "success") freq = 520;
      if (type === "error") freq = 220;

      osc.frequency.value = freq;
      const now = ctx.currentTime;
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now);
      osc.stop(now + 0.18);
    }

    const state = {
      currentStep: 1, 
      maxStep: 11, 

      teamName: "",
      role: "",

      scenario: `A researcher is conducting an in-depth study of Kazuo Ishiguro‚Äôs Never Let Me Go to examine the construction of ethical dilemmas, memory, and the search for meaning within a dystopian society. The study will explore how Ishiguro uses first-person narration, restrained emotional tone, and recurring motifs (such as art, donations, and lost places) to reveal the inner worlds of Kathy, Tommy, and Ruth as they confront questions of humanity, fate, and personal agency. Particular attention will be paid to how the novel addresses moral ambiguity, the tension between individual desires and societal expectations, and the role of memory in shaping identity and relationships.`,
      keywords: [],
      theories: [],
      methodology: "",
      methods: [],

      xp: {
        theory: 0,
        methodology: 0,
        methods: 0,
        coherence: 0,
        defense: 0,
        challenge: 0,
      },
    };

    const broadTypes = [
        "Text, Form & Structure",
        "History, Society & Power",
        "Identity, Gender, Sexuality, Race & Disability",
        "Mind, Emotion, Experience & Trauma",
        "Ethics, Values, Spirituality & Nature",
        "Reader, Audience & Interpretation",
    ];

    const theoriesList = [
      "Formalism / New Criticism",
      "Structuralism",
      "Narratology",
      "Semiotics",
      "Deconstruction / Post-Structuralism",
      "Postmodernism",
      "Historical / Biographical Criticism",
      "New Historicism",
      "Cultural Studies",
      "Marxist Theory",
      "Postcolonial Theory",
      "Orientalism",
      "Reception Theory",
      "Romanticism",
      "Feminist Theory",
      "Gender Theory",
      "Queer Theory",
      "Critical Race Theory",
      "Disability Theory",
      "Intersectionality",
      "Afrofuturism",
      "Psychoanalytic Theory",
      "Existentialism",
      "Phenomenology",
      "Trauma Theory",
      "Ecocriticism",
      "Transcendentalism",
      "Humanism",
      "Reader-Response Theory",
    ];

    const methodologies = ["Qualitative", "Quantitative", "Mixed Methods"];

    const methodsList = [
      "Archival Methods",
      "Auto/biography as a Research Method",
      "Oral History as a Research Method",
      "Visual Methodologies",
      "Discourse Analysis",
      "Ethnographic Methods",
      "Quantitative Methods",
      "Textual Analysis as a Research Method",
      "Interviewing",
      "Creative Writing as a Research Method",
      "Digital Humanities",
    ];

    const scenarioPresets = [
      {
        id: "nlg",
        title: "Never Let Me Go ‚Äî Ethics, Memory & Control",
        text: "A researcher is conducting an in-depth study of Kazuo Ishiguro's Never Let Me Go to examine ethical dilemmas, memory, and the search for meaning within a dystopian society. The study explores how first-person narration, restrained emotional tone, and recurring motifs (such as art, donations, and lost places) reveal the inner worlds of the main characters as they confront questions of humanity, fate, and personal agency."
      },
      {
        id: "ttc",
        title: "A Tale of Two Cities ‚Äî Class, Revolution & Sacrifice",
        text: "A researcher is studying Charles Dickens's A Tale of Two Cities to investigate how the novel represents class struggle, political violence, and personal sacrifice during the French Revolution. The study focuses on the contrast between London and Paris, the motif of 'recalled to life', and the moral transformation of characters such as Sydney Carton."
      },
      {
        id: "generic",
        title: "Generic Literary Scenario ‚Äî Identity & Power",
        text: "A researcher examines a modern novel in which the protagonist struggles with identity, social expectations, and institutional power. The study explores how memory, narrative voice, and recurring images of confinement and freedom construct the character's search for selfhood."
      }
    ];


    const roles = [
      {
        id: "Theorist",
        name: "Theorist",
        desc: "Specialist in choosing theories; may select one extra theory (max 3 theories)."
      },
      {
        id: "Methodologist",
        name: "Methodologist",
        desc: "Focuses on research strategy; immune to one methodology penalty."
      },
      {
        id: "Analyst",
        name: "Analyst",
        desc: "Tool master; may select one extra method (max 4 methods)."
      },
      {
        id: "Interpreter",
        name: "Interpreter",
        desc: "Patch-maker; may fix one mismatch without penalty."
      },
      {
        id: "Historian",
        name: "Historian",
        desc: "Context expert; bonus if using archival / historical methods."
      },
      {
        id: "Investigator",
        name: "Investigator",
        desc: "Critical challenger; may challenge once without risking XP."
      },
    ];
    
    // --- Step Configuration Mapping ---
    const stepMap = {
        1: { type: 'narrative', title: "Prelude: The Awakening", render: renderNarrativePrelude },
        2: { type: 'setup', title: "Step 1: Team & Role", render: renderStep1 },
        3: { type: 'narrative', title: "ACT I: The Call", render: renderNarrativeActI },
        4: { type: 'setup', title: "Step 2: Mission & Keywords", render: renderStep2 },
        5: { type: 'narrative', title: "ACT II: Scene I (Theory Forest)", render: renderNarrativeActIISceneI },
        6: { type: 'setup', title: "Step 3: Theory Selection", render: renderStep3 },
        7: { type: 'narrative', title: "ACT II: Scene II (Methodology Bridge)", render: renderNarrativeActIISceneII },
        8: { type: 'setup', title: "Step 4: Methodology", render: renderStep4 },
        9: { type: 'narrative', title: "ACT III: Scene I (Methods Dungeon)", render: renderNarrativeActIIISceneI },
        10: { type: 'setup', title: "Step 5: Methods", render: renderStep5 },
        11: { type: 'setup', title: "Step 6: Summary & XP", render: renderStep6 },
    };

    function renderStepsBar() {
      const setupSteps = [
        "Team & Role",
        "Mission & Keywords",
        "Theory Selection",
        "Methodology",
        "Methods",
        "Summary & XP",
      ];
      
      const bar = document.getElementById("stepsBar");
      bar.innerHTML = "";
      setupSteps.forEach((label, index) => {
        const stepNum = (index * 2) + 2; 
        const pill = document.createElement("div");
        pill.className = "step-pill";

        // Logic for setting active/completed status for setup screens
        if (state.currentStep >= stepNum) {
             pill.classList.add("completed");
        }
        if (state.currentStep === stepNum) {
            pill.classList.add("active");
            pill.classList.remove("completed");
        }
        // Special handling for step 6 (step 11 in total sequence)
        if (stepNum === 11 && state.currentStep === 11) {
            pill.classList.add("active");
        }
        
        pill.innerHTML = `
          <span class="num">${index + 1}</span>
          <span>${label}</span>
        `;
        bar.appendChild(pill);
      });
    }

    function goToStep(step) {
      if (step < 1 || step > state.maxStep) return;
      state.currentStep = step;
      renderStepsBar();
      renderStepContent();
    }

    function nextStep() {
      if (state.currentStep < state.maxStep) {
        state.currentStep++;
        renderStepsBar();
        renderStepContent();
        playSfx("click");
      }
    }

    function prevStep() {
      if (state.currentStep > 1) {
        state.currentStep--;
        renderStepsBar();
        renderStepContent();
        playSfx("click");
      }
    }


    function loadScenarioPreset(index) {
      const i = parseInt(index, 10);
      if (isNaN(i) || !scenarioPresets[i]) return;
      const preset = scenarioPresets[i];
      state.scenario = preset.text;
      const textarea = document.getElementById("scenarioText");
      if (textarea) {
        textarea.value = preset.text;
      }
      playSfx("success");
    }

    function addKeyword() {
      const input = document.getElementById("keywordInput");
      const kw = (input.value || "").trim();
      if (!kw) return;
      state.keywords.push({ text: kw, type: "" });
      input.value = "";
      renderKeywordsList();
    }

    function updateKeywordType(index, type) {
      if (state.keywords[index]) {
        state.keywords[index].type = type;
      }
    }

    function removeKeyword(index) {
      state.keywords.splice(index, 1);
      renderKeywordsList();
    }

    function renderKeywordsList() {
      const container = document.getElementById("keywordsList");
      if (!container) return;
      container.innerHTML = "";
      if (state.keywords.length === 0) {
        container.innerHTML =
          '<div class="hint">No keywords added yet. Start with words like ‚Äúmemory‚Äù, ‚Äúclass struggle‚Äù, ‚Äúgender‚Äù, ‚Äúempire‚Äù, ‚Äúnature‚Äù, etc.</div>';
        return;
      }
      state.keywords.forEach((k, i) => {
        const div = document.createElement("div");
        div.className = "keyword-item";
        div.innerHTML = `
          <span class="keyword">${k.text}</span>
          <select onchange="updateKeywordType(${i}, this.value)">
            <option value="">‚Äì broad type ‚Äì</option>
            ${broadTypes
              .map(
                (t) =>
                  `<option value="${t}" ${
                    k.type === t ? "selected" : ""
                  }>${t}</option>`
              )
              .join("")}
          </select>
          <button class="keyword-remove" onclick="removeKeyword(${i})">√ó</button>
        `;
        container.appendChild(div);
      });
    }

    function toggleTheory(theory) {
      const idx = state.theories.indexOf(theory);
      // DYNAMIC MAX THEORIES: 3 for Theorist, 2 otherwise
      const maxTheories = state.role === "Theorist" ? 3 : 2;
      playSfx("click");

      if (idx === -1) {
        if (state.theories.length < maxTheories) {
          state.theories.push(theory);
        } else {
          alert(`You can only choose a maximum of ${maxTheories} theories. If you are Theorist, you may choose one extra.`);
          return;
        }
      } else {
        state.theories.splice(idx, 1);
      }
      renderStepContent();
    }

    function toggleMethodology(m) {
      state.methodology = m;
      renderStepContent();
      playSfx("click");
    }

    function toggleMethod(m) {
      const idx = state.methods.indexOf(m);
      const maxMethods = state.role === "Analyst" ? 4 : 3;
      playSfx("click");

      if (idx === -1) {
        if (state.methods.length < maxMethods) {
          state.methods.push(m);
        } else {
          alert(`You can only choose a maximum of ${maxMethods} methods. If you are Analyst, you get this extra slot.`);
          return;
        }
      } else {
        state.methods.splice(idx, 1);
      }
      renderStepContent();
    }

    function selectRole(roleId) {
      state.role = roleId;
      renderStepContent();
      playSfx("success");
    }

    function updateXP(field, value) {
      const v = parseInt(value, 10);
      state.xp[field] = isNaN(v) ? 0 : v;
      renderStepContent();
    }

    function calculateTotalXP() {
      const xp = state.xp;
      return (
        xp.theory +
        xp.methodology +
        xp.methods +
        xp.coherence +
        xp.defense +
        xp.challenge
      );
    }

    function getRankFromXP(total) {
      if (total >= 15) return "Master Researcher";
      if (total >= 10) return "Advanced Investigator";
      if (total >= 5) return "Scholar-in-Training";
      return "Novice Researcher";
    }
    
    // --- Narrative Render Functions (Quotes used instead of bolding) ---

    function createNarrativeBlock(title, content) {
        const block = document.createElement("div");
        block.className = "narrative-block";
        block.innerHTML = `<h3>${title}</h3><p>${content}</p>`;
        return block;
    }

    function renderNarrativePrelude() {
        const wrapper = document.createElement("div");
        const title = "Prelude: The Awakening of the Boon üåü";
        const content = `
            The path to knowledge is never uniform. Before any great journey begins, the Hero must first look inward, recognizing the innate "gift" that sets them apart. This is the moment where "Talent" meets "Vocation".
            Before studying the research problem, the Hero recognizes a fundamental "Boon" or "Innate Talent" they possess‚Äîtheir specific "Researcher Class" (Theorist, Analyst, etc.). This isn't a learned skill but a natural inclination they are "born with".
            The Hero must choose one talent to guide their quest. The Narrative Hook: If the Hero fails to use their chosen "Boon" strategically at the critical moments, that talent will wither and be useless against the "Final Boss", potentially leading to a major setback.
        `;
        wrapper.appendChild(createNarrativeBlock(title, content));
        
        const buttons = document.createElement("div");
        buttons.className = "buttons";
        buttons.innerHTML = `
          <button class="btn secondary" disabled>‚Üê Back (Start)</button>
          <button class="btn primary" onclick="nextStep()">Continue ‚Üí</button>
        `;
        wrapper.appendChild(buttons);
        return wrapper;
    }
    
    function renderNarrativeActI() {
        const wrapper = document.createElement("div");
        const title = "ACT I: The Call to Adventure (The Problem) üìú";
        const content = `
            The story begins in the shadowed library halls, where the Hero receives the "Mission"‚Äîa specific research problem or a profound intellectual conflict. This problem immediately reveals itself as the "Final Boss", the monolithic source of conflict that must be overcome. It‚Äôs a formidable intellectual challenge.
            The Hero‚Äôs first and most crucial task is not to rush toward confrontation, but to understand the "Boss's Nature". This is done by performing a systematic, tactical "reconnaissance": identifying "Problem Keywords" (concrete terms like 'memory', 'ethics', or 'class struggle') and grouping them into "Broader Types" (e.g., Psychological / Trauma). This strategic mapping provides the Hero with the conceptual "compass" needed to navigate the challenges ahead.
        `;
        wrapper.appendChild(createNarrativeBlock(title, content));
        
        const buttons = document.createElement("div");
        buttons.className = "buttons";
        buttons.innerHTML = `
          <button class="btn secondary" onclick="prevStep()">‚Üê Back</button>
          <button class="btn primary" onclick="nextStep()">Continue ‚Üí</button>
        `;
        wrapper.appendChild(buttons);
        return wrapper;
    }
    
    function renderNarrativeActIISceneI() {
        const wrapper = document.createElement("div");
        const title = "ACT II, Scene I: Through the Theory Forest üå≥";
        const content = `
            The Hero now enters the "Theory Forest", a dense and sprawling landscape of ideas where thousands of paths (theories) twist and intersect. The Hero's only reliable guide is the "conceptual compass" derived from the "Problem's Nature" (the Broader Types).
            The Hero must select "two theories" that serve as the fundamental intellectual spells and frameworks. The Danger: Choosing the wrong theory is like taking a misleading path‚Äîit guarantees failure later. The "Theorist" class, however, may have the power to "redraw one path".
        `;
        wrapper.appendChild(createNarrativeBlock(title, content));
        
        const buttons = document.createElement("div");
        buttons.className = "buttons";
        buttons.innerHTML = `
          <button class="btn secondary" onclick="prevStep()">‚Üê Back</button>
          <button class="btn primary" onclick="nextStep()">Continue ‚Üí</button>
        `;
        wrapper.appendChild(buttons);
        return wrapper;
    }
    
    function renderNarrativeActIISceneII() {
        const wrapper = document.createElement("div");
        const title = "ACT II, Scene II: Crossing the Methodology Bridge üåâ";
        const content = `
            The Hero has the map (Theory) and now approaches the crucial strategic choke point: the "Methodology Bridge". Here, the Hero must decide the 'scale' and 'nature' of their attack‚Äî"Qualitative," "Quantitative," or "Mixed Methods."
            The Danger: Choosing the wrong bridge means ending up in the wrong dungeon. For example, crossing the Quantitative bridge with purely interpretive theories will render the tools collected later useless. The "Methodologist" class, whose talent grants "immunity to strategy failure", can correct a wrong choice here.
        `;
        wrapper.appendChild(createNarrativeBlock(title, content));
        
        const buttons = document.createElement("div");
        buttons.className = "buttons";
        buttons.innerHTML = `
          <button class="btn secondary" onclick="prevStep()">‚Üê Back</button>
          <button class="btn primary" onclick="nextStep()">Continue ‚Üí</button>
        `;
        wrapper.appendChild(buttons);
        return wrapper;
    }
    
    function renderNarrativeActIIISceneI() {
        const wrapper = document.createElement("div");
        const title = "ACT III, Scene I: Forging Weapons in the Methods Dungeon üè∞";
        const content = `
            The Hero has a map and a strategic plan. Now, they must descend into the "Methods Dungeon", the armory where the practical "tools" and "weapons" (the research methods) are kept.
            The Arsenal: The Hero selects "2‚Äì3 specific methods"‚Äîthe exact tools needed to defeat the problem. The "Analyst" class, the Tool Master, can utilize their talent to "forge one extra, specific weapon".
            The Coherence Test: The final weapons must align perfectly with the chosen Methodology. The "Historian" gains a passive advantage when using context-focused tools like Archival methods.
        `;
        wrapper.appendChild(createNarrativeBlock(title, content));
        
        const buttons = document.createElement("div");
        buttons.className = "buttons";
        buttons.innerHTML = `
          <button class="btn secondary" onclick="prevStep()">‚Üê Back</button>
          <button class="btn primary" onclick="nextStep()">Continue ‚Üí</button>
        `;
        wrapper.appendChild(buttons);
        return wrapper;
    }


    function renderStepContent() {
      const container = document.getElementById("stepContent");
      const s = state.currentStep;
      container.innerHTML = "";

      const step = stepMap[s];
      if (step) {
          container.appendChild(step.render());
      } else {
          container.innerHTML = '<div class="hint">Error: Invalid Step.</div>';
      }
      
      if (s === 4) {
          renderKeywordsList();
      }
    }

    function renderStep1() {
      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 1 ‚Äî Team & Role</h2>
          <div class="step-tagline">Name your team and choose your Researcher Class (Your Boon).</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Team Setup</h3>
            <small>Each group works at one device. One team name per group.</small>
            <label for="teamName">Team Name</label>
            <input type="text" id="teamName" placeholder="e.g. The Method Mages"
              value="${state.teamName || ""}"
              oninput="state.teamName = this.value" />
          </div>
          <div class="card">
            <h3>Choose Your Role (The Hero's Boon)</h3>
            <small>Each group selects exactly one role‚Äîthis is your innate talent.</small>
            <div class="roles-grid">
              ${roles
                .map(
                  (r) => `
                <label class="role-card ${
                  state.role === r.id ? "selected" : ""
                }" onclick="selectRole('${r.id}')">
                  <input type="radio" name="role" value="${r.id}" ${
                    state.role === r.id ? "checked" : ""
                  } />
                  <span class="name">${r.name}</span>
                  <span class="desc">${r.desc}</span>
                </label>
              `
                )
                .join("")}
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back (Prelude)</button>
        <button class="btn primary" onclick="nextStep()">Next ‚Üí</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    function renderStep2() {
      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 2 ‚Äî Mission & Keywords</h2>
          <div class="step-tagline">Study the Final Boss's nature and extract problem keywords.</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Research Scenario</h3>
            <small>The Mission Scroll defining the Final Boss.</small>
            <label for="scenarioText">Scenario Text</label>
            <div class="scenario-tools">
              <label for="scenarioPreset"><small>Or choose a sample scenario:</small></label>
              <select id="scenarioPreset" onchange="loadScenarioPreset(this.value)">
                <option value="">‚Äî Select a preset scenario ‚Äî</option>
                ${scenarioPresets
                  .map((s, i) => `<option value="${i}">${s.title}</option>`)
                  .join("")}
              </select>
            </div>
            <textarea id="scenarioText"
              oninput="state.scenario = this.value">${state.scenario}</textarea>
            <div class="hint">
              Step 2A: Identify and list **Problem Keywords** showing the conflict (e.g., memory, class struggle, ethics).
            </div>
          </div>
          <div class="card">
            <h3>Keywords & Broad Types (The Conceptual Compass)</h3>
            <small>Step 2B: Map concrete keywords into broader conceptual types.</small>
            <div class="keyword-row">
              <input type="text" id="keywordInput" placeholder="e.g. memory, class struggle, cloning" />
              <button class="btn secondary" style="padding:5px 10px;font-size:0.78rem" onclick="addKeyword()">+ Add</button>
            </div>
            <div id="keywordsList"></div>
            <div class="hint" style="margin-top:6px;">
              Example: <em>memory</em> ‚Üí <strong>Psychological / Trauma</strong>;<br/>
              <em>class struggle</em> ‚Üí <strong>Social / Economic / Marxist</strong>.
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back (ACT I)</button>
        <button class="btn primary" onclick="nextStep()">Next ‚Üí</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    function renderStep3() {
      // Dynamic max theories logic: 3 for Theorist, 2 otherwise
      const maxTheories = state.role === "Theorist" ? 3 : 2; 
      const isLimitReached = state.theories.length >= maxTheories;
      const roleIsTheorist = state.role === "Theorist";
      
      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 3 ‚Äî Theory Selection (Theory Forest üå≥)</h2>
          <div class="step-tagline">Choose ${maxTheories} theories that match your conceptual compass and scenario.</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Theories (Intellectual Spells)</h3>
            <small>You currently have ${state.theories.length} / ${maxTheories} selected. ${roleIsTheorist ? 'Role: Theorist (may select one extra theory).' : ''}</small>
            <div class="options-list">
              ${theoriesList
                .map(
                  (t) => {
                    const isSelected = state.theories.includes(t);
                    const isDisabled = isLimitReached && !isSelected;
                    const itemClass = isDisabled ? 'option-item limit-reached' : 'option-item';
                    return `
                      <div class="${itemClass}">
                        <input type="checkbox" id="theory-${t}" ${isSelected ? "checked" : ""}
                          ${isDisabled ? "disabled" : ""}
                          onchange="toggleTheory('${t.replace(/'/g, "\\'")}')" />
                        <label for="theory-${t}">${t}</label>
                      </div>
                    `;
                  }
                )
                .join("")}
            </div>
            <div class="hint">Hint: First match your problem keywords to broad types, then pick theories in that lane.</div>
            <details class="compact-theory">
              <summary>Compact Theory‚ÄìProblem Type Table</summary>
              <div class="theory-table">
                <table>
                  <tr>
                    <th>Problem Type</th>
                    <th>Example Theories</th>
                  </tr>
                  <tr>
                    <td>Text / Form / Narrative</td>
                    <td>Formalism/New Criticism, Structuralism, Narratology, Semiotics, Deconstruction/Post-Structuralism, Postmodernism</td>
                  </tr>
                  <tr>
                    <td>History / Society / Power</td>
                    <td>Historical/Biographical, New Historicism, Cultural Studies, Marxist, Postcolonial, Orientalism, Afrofuturism</td>
                  </tr>
                  <tr>
                    <td>Identity / Gender / Race / Disability</td>
                    <td>Feminist, Gender, Queer, Critical Race, Disability, Intersectionality</td>
                  </tr>
                  <tr>
                    <td>Mind / Emotion / Experience / Trauma</td>
                    <td>Psychoanalytic, Phenomenology, Existentialism, Trauma Theory</td>
                  </tr>
                  <tr>
                    <td>Ethics / Values / Nature / Spirituality</td>
                    <td>Humanism, Romanticism, Transcendentalism, Ecocriticism</td>
                  </tr>
                  <tr>
                    <td>Reader / Audience / Interpretation</td>
                    <td>Reader-Response, Reception Theory</td>
                  </tr>
                </table>
              </div>
            </details>
          </div>
          <div class="card">
            <h3>Current Choices</h3>
            <small>The theories define your analytical lens.</small>
            <div class="summary-block">
              <div class="summary-line"><strong>Team:</strong> ${state.teamName || "‚Äî"}</div>
              <div class="summary-line"><strong>Role:</strong> ${
                state.role || "‚Äî"
              }</div>
              <div class="summary-line"><strong>Keywords:</strong> ${
                state.keywords.length
                  ? state.keywords
                      .map(
                        (k) =>
                          `${k.text}${
                            k.type ? " (" + k.type.split("/")[0].trim() + ")" : ""
                          }`
                      )
                      .join(", ")
                  : "‚Äî"
              }</div>
              <div class="summary-line"><strong>Theories:</strong> ${
                state.theories.length ? state.theories.join(", ") : "‚Äî"
              }</div>
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back (ACT II, Scene I)</button>
        <button class="btn primary" onclick="nextStep()">Next ‚Üí</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    function renderStep4() {
      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 4 ‚Äî Methodology (Methodology Bridge üåâ)</h2>
          <div class="step-tagline">Choose one research methodology (Your strategic route).</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Methodology Options</h3>
            <small>Pick exactly one strategic route. ${state.role === "Methodologist" ? 'Role: Methodologist (may change once without penalty).' : ''}</small>
            <div class="options-list">
              ${methodologies
                .map(
                  (m) => `
                  <div class="option-item">
                    <input type="radio" name="methodology" id="meth-${m}" ${
                    state.methodology === m ? "checked" : ""
                  } onchange="toggleMethodology('${m}')" />
                    <label for="meth-${m}">
                      <strong>${m}</strong><br/>
                      ${
                        m === "Qualitative"
                          ? "Interpretive, focuses on meaning, depth, and textual analysis."
                          : m === "Quantitative"
                          ? "Numeric, counts things, uses statistics and measurements."
                          : "Combines qualitative interpretation with some numeric or corpus-based data."
                      }
                    </label>
                  </div>
                `
                )
                .join("")}
            </div>
          </div>
          <div class="card">
            <h3>Reminder: Strategy Coherence</h3>
            <small>Your methodology must match the demands of your theories.</small>
            <div class="summary-block">
              <div class="summary-line"><strong>Theories:</strong> ${
                state.theories.length ? state.theories.join(", ") : "‚Äî"
              }</div>
              <div class="summary-line"><strong>Methodology:</strong> ${
                state.methodology || "‚Äî"
              }</div>
            </div>
            <div class="hint">
              Example: Trauma Theory + Narratology usually pair with <strong>Qualitative</strong>.<br/>
              A corpus-based stylistic study might use <strong>Quantitative</strong> or <strong>Mixed Methods</strong>.
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back (ACT II, Scene II)</button>
        <button class="btn primary" onclick="nextStep()">Next ‚Üí</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    function renderStep5() {
      const maxMethods = state.role === "Analyst" ? 4 : 3;
      const isLimitReached = state.methods.length >= maxMethods;
      const roleIsAnalyst = state.role === "Analyst";

      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 5 ‚Äî Methods (Methods Dungeon üè∞)</h2>
          <div class="step-tagline">Choose 2‚Äì${maxMethods} tools/weapons that fit your strategy and theories.</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Methods (Tools/Weapons)</h3>
            <small>You currently have ${state.methods.length} / ${maxMethods} selected. ${roleIsAnalyst ? 'Role: Analyst (max 4 methods).' : ''}</small>
            <div class="options-list">
              ${methodsList
                .map(
                  (m) => {
                    const isSelected = state.methods.includes(m);
                    const isDisabled = isLimitReached && !isSelected;
                    const itemClass = isDisabled ? 'option-item limit-reached' : 'option-item';
                    return `
                      <div class="${itemClass}">
                        <input type="checkbox" id="method-${m}" ${isSelected ? "checked" : ""}
                          ${isDisabled ? "disabled" : ""}
                          onchange="toggleMethod('${m.replace(/'/g, "\\'")}')" />
                        <label for="method-${m}">${m}</label>
                      </div>
                    `;
                  }
                )
                .join("")}
            </div>
          </div>
          <div class="card">
            <h3>Arsenal Consistency Check</h3>
            <small>Does your toolset match your strategy and theory?</small>
            <div class="summary-block">
              <div class="summary-line"><strong>Theories:</strong> ${
                state.theories.length ? state.theories.join(", ") : "‚Äî"
              }</div>
              <div class="summary-line"><strong>Methodology:</strong> ${
                state.methodology || "‚Äî"
              }</div>
              <div class="summary-line"><strong>Methods:</strong> ${
                state.methods.length ? state.methods.join(", ") : "‚Äî"
              }</div>
            </div>
            <div class="hint">
              Example: Qualitative + Trauma Theory ‚Üí <strong>Textual Analysis, Discourse Analysis, Interviews</strong>.
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back (ACT III, Scene I)</button>
        <button class="btn primary" onclick="nextStep()">Next ‚Üí</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    function renderStep6() {
      const totalXP = calculateTotalXP();
      const rank = getRankFromXP(totalXP);
      const roleIsInterpreter = state.role === "Interpreter";
      const roleIsInvestigator = state.role === "Investigator";
      
      const wrapper = document.createElement("div");
      wrapper.className = "step-container";
      wrapper.innerHTML = `
        <div class="step-header">
          <h2>Step 6 ‚Äî Summary & XP (ACT III, Scene II: Boss Battle)</h2>
          <div class="step-tagline">Review your full research pathway and track XP with your GM.</div>
        </div>
        <div class="grid two-col">
          <div class="card">
            <h3>Research Pathway Summary</h3>
            <small>The blueprint for defeating the Final Boss.</small>
            <div class="summary-block">
              <div class="summary-line"><strong>Team:</strong> ${
                state.teamName || "‚Äî"
              }</div>
              <div class="summary-line"><strong>Role:</strong> ${
                state.role || "‚Äî"
              }</div>
              <div class="summary-line"><strong>Scenario (The Final Boss):</strong><br/>
                ${state.scenario.slice(0, 200)}${
        state.scenario.length > 200 ? "..." : ""
      }
              </div>
              <div class="summary-line"><strong>Keywords:</strong> ${
                state.keywords.length
                  ? state.keywords
                      .map(
                        (k) =>
                          `${k.text}${
                            k.type ? " (" + k.type.split("/")[0].trim() + ")" : ""
                          }`
                      )
                      .join(", ")
                  : "‚Äî"
              }</div>
              <div class="summary-line"><strong>Theories:</strong> ${
                state.theories.length ? state.theories.join(", ") : "‚Äî"
              }</div>
              <div class="summary-line"><strong>Methodology:</strong> ${
                state.methodology || "‚Äî"
              }</div>
              <div class="summary-line"><strong>Methods:</strong> ${
                state.methods.length ? state.methods.join(", ") : "‚Äî"
              }</div>
            </div>
            <div class="hint">
              Use this pathway when you explain your choices in the class ‚ÄúBoss Battle‚Äù.
              ${roleIsInterpreter ? '<br/>**Interpreter Boon:** May fix one mismatch without penalty.' : ''}
              ${roleIsInvestigator ? '<br/>**Investigator Boon:** May challenge one rival without risking XP.' : ''}
            </div>
          </div>
          <div class="card">
            <h3>XP Tracking (for GM & Team)</h3>
            <small>Fill these with your teacher during or after presentations.</small>
            <div class="xp-grid">
              <div class="xp-field">
                <label>Theory XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.theory}"
                  oninput="updateXP('theory', this.value)" />
              </div>
              <div class="xp-field">
                <label>Methodology XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.methodology}"
                  oninput="updateXP('methodology', this.value)" />
              </div>
              <div class="xp-field">
                <label>Methods XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.methods}"
                  oninput="updateXP('methods', this.value)" />
              </div>
              <div class="xp-field">
                <label>Coherence XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.coherence}"
                  oninput="updateXP('coherence', this.value)" />
              </div>
              <div class="xp-field">
                <label>Defense XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.defense}"
                  oninput="updateXP('defense', this.value)" />
              </div>
              <div class="xp-field">
                <label>Challenge XP (+1)</label>
                <input type="number" min="0" max="5"
                  value="${state.xp.challenge}"
                  oninput="updateXP('challenge', this.value)" />
              </div>
            </div>
            <div class="xp-total">
              <strong>Total XP:</strong> ${totalXP}
              <div class="rank-label">
                Rank: <strong>${rank}</strong>
              </div>
            </div>
            <div class="hint">
              <h4>Revised XP Rubric:</h4>
              <p style="margin-top: 0; margin-bottom: 5px;"><strong>I. Core Research Pathway Alignment (Max +3 XP):</strong></p>
              <ul>
                  <li>Theory Alignment (+1 XP): Awarded if all chosen theories directly and logically address the Broader Types identified from the Problem Keywords.</li>
                  <li>Methodology Alignment (+1 XP): Awarded if the chosen Methodology (Qualitative/Quantitative/Mixed) is the appropriate high-level strategy for the selected Theories.</li>
                  <li>Methods Alignment (+1 XP): Awarded if the 2‚Äì4 chosen methods are the correct practical tools used by the selected Methodology.</li>
              </ul>
              <p style="margin-top: 10px; margin-bottom: 5px;"><strong>II. Design Integration and Justification (Max +3 XP):</strong></p>
              <ul>
                  <li>Pathway Coherence (+1 XP): Awarded if the team can clearly articulate 'why' the entire chain (Problem ‚Üí Theory ‚Üí Methodology ‚Üí Methods) is seamlessly integrated.</li>
                  <li>Defense Success (+1 XP): Awarded if the team successfully withstands questioning from the GM/class, demonstrating mastery of their design choices.</li>
                  <li>Challenge Success (+1 XP): Awarded if the team successfully executes a challenge against another group's design, correctly identifying a significant flaw.</li>
              </ul>
              <p style="margin-top: 10px; margin-bottom: 5px; color: var(--danger);"><strong>III. Penalties:</strong></p>
              <ul>
                  <li>Inconsistency Penalty (-1 XP): Assessed if a core strategic link is broken (e.g., selecting Qualitative but using Statistical Analysis methods). This can occur multiple times.</li>
                  <li>Unsuccessful Challenge (-1 XP): Assessed if a team challenges a rival, but the challenge is found to be incorrect. (Waived if Investigator Boon is used).</li>
              </ul>
            </div>
          </div>
        </div>
      `;

      const buttons = document.createElement("div");
      buttons.className = "buttons";
      buttons.innerHTML = `
        <button class="btn secondary" onclick="prevStep()">‚Üê Back</button>
        <button class="btn primary" onclick="goToStep(1)">Start Over ‚Ü∫</button>
      `;
      wrapper.appendChild(buttons);
      return wrapper;
    }

    // Initialize
    renderStepsBar();
    renderStepContent();
    // Make keyword functions globally visible for inline handlers:
    window.updateKeywordType = updateKeywordType;
    window.removeKeyword = removeKeyword;
    window.toggleTheory = toggleTheory;
    window.toggleMethodology = toggleMethodology;
    window.toggleMethod = toggleMethod;
    window.selectRole = selectRole;
    window.addKeyword = addKeyword;
    window.prevStep = prevStep;
    window.nextStep = nextStep;
    window.goToStep = goToStep;
    window.updateXP = updateXP;
  </script>
</body>
</html>
